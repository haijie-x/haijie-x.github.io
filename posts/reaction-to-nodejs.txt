1:HL["/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2",{"as":"font","type":"font/woff2"}]
2:HL["/_next/static/css/34c9aa3dac019c99.css",{"as":"style"}]
0:["JXPeZoXc9Nz75w5nwf-9S",[[["",{"children":["posts",{"children":[["slug","reaction-to-nodejs","c"],{"children":["__PAGE__?{\"slug\":[\"reaction-to-nodejs\"]}",{}]}]}]},"$undefined","$undefined",true],"$L3",[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/34c9aa3dac019c99.css","precedence":"next"}]],["$L4",["$","meta",null,{"name":"next-size-adjust"}]]]]]]
5:I{"id":"8112","chunks":["553:static/chunks/553-b75a1ab1e88d23c9.js","185:static/chunks/app/layout-ae43402e7109a0fc.js"],"name":"","async":false}
6:I{"id":"9553","chunks":["553:static/chunks/553-b75a1ab1e88d23c9.js","185:static/chunks/app/layout-ae43402e7109a0fc.js"],"name":"","async":false}
7:I{"id":"1588","chunks":["272:static/chunks/webpack-ba6ac5b5713db877.js","417:static/chunks/44856608-9ee913c47fa02561.js","920:static/chunks/920-b802bbbd4288d489.js"],"name":"","async":false}
8:I{"id":"4737","chunks":["272:static/chunks/webpack-ba6ac5b5713db877.js","417:static/chunks/44856608-9ee913c47fa02561.js","920:static/chunks/920-b802bbbd4288d489.js"],"name":"","async":false}
3:[["$","html",null,{"lang":"en","children":[["$","link",null,{"rel":"icon","href":"/logo.svg","type":"image/x-icon"}],["$","title",null,{"children":"Hai"}],["$","body",null,{"className":"antialiased min-h-screen bg-white text-slate-900 __className_a64ecd","children":["$","div",null,{"className":"max-w-2xl mx-auto py-10 px-4","children":[["$","header",null,{"children":["$","div",null,{"className":"flex items-center justify-between","children":[["$","$L5",null,{}],["$","nav",null,{"className":"ml-auto text-sm font-medium space-x-6","children":[["$","$L6",null,{"href":"/","children":"Home"}],["$","$L6",null,{"href":"/about","children":"About"}]]}]]}]}],["$","main",null,{"children":["$","$L7",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L8",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$","$L7",null,{"parallelRouterKey":"children","segmentPath":["children","posts","children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L8",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$","$L7",null,{"parallelRouterKey":"children","segmentPath":["children","posts","children",["slug","reaction-to-nodejs","c"],"children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L8",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$L9",null],"segment":"__PAGE__?{\"slug\":[\"reaction-to-nodejs\"]}"},"styles":[]}],"segment":["slug","reaction-to-nodejs","c"]},"styles":[]}],"segment":"posts"},"styles":[]}]}],["$","footer",null,{"className":"mt-10","children":[["$","hr",null,{"className":"my-4"}],["$","small",null,{"className":"flex justify-between","children":["@ Hai",["$","nav",null,{"className":"underline decoration-1","children":[["$","$L6",null,{"href":"https://github.com/haijie-x","className":"mr-3","children":"github"}],["$","$L6",null,{"href":"https://twitter.com/__haijie","children":"twitter"}]]}]]}]]}]]}]}]]}],null]
4:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"Reaction to Node.js"}],["$","meta","2",{"name":"description","content":"《深入浅出Node.js》阅读摘录"}],["$","meta","3",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
9:["$","article",null,{"className":"py-6 prose dark:prose-invert","children":[["$","h1",null,{"className":"mb-4 break-all","children":"Reaction to Node.js"}],["$","p",null,{"className":"text-slate-700","children":"《深入浅出Node.js》阅读摘录"}],["$","hr",null,{"className":"my-4"}],[["$","p",null,{"children":"最近在读朴灵老师的《深入学习 Node.js》，虽然这本书出版于 2013 年，距离现在已有十年，但风评都说它是 Node.js 的圣经，正好本人在学习 Node.Js，故在此做些关于该书的笔记与摘录。"}],"\n",["$","p",null,{"children":"本篇文章的目录将于这本书保持一致，方便自己回顾学习与读者阅读，以下思考将统称 Node.js 为 Node。"}],"\n",["$","h2",null,{"children":"1 Node 简介"}],"\n",["$","h3",null,{"children":"1.1 Node 的诞生历程"}],"\n",["$","p",null,{"children":["众所周知，学习一门知识需要了解其历史，下面来聊聊 Node 是如何诞生的。",["$","br",null,{}],"\n","2009 年 3 月，Ryan Dahl 在其博客上宣布准备基于 V8 创建一个轻量级的 Web 服务器并提供一套库。",["$","br",null,{}],"\n","2009 年 5 月 Ryan Dahl 在 github 上发布了 nodejs 的最初版本。",["$","br",null,{}],"\n","2012 年 1 月底，Ryan Dahl 在对 Node 架构设计满意的情况下，将掌门人的身份转交给 Isaac Z. Schlueter，自己转向一些研究项目。Isaac Z. Schlueter 是 Node 的包管理器 NPM 的作者，之后 Node 的版本发布和 bug 修复等工作由他接手。",["$","br",null,{}],"\n","随后，Node 的发布计划主要集中在性能提升上，在 v0.14 之后，正式发布出 v1.0 版本。"]}],"\n",["$","h3",null,{"children":"1.2 Node 的命名与起源"}],"\n",["$","p",null,{"children":"起初，Node 作者只是想开发一款 Web 应用，它又是如何发展成拥有庞大生态的 Node 呢。"}],"\n",["$","h4",null,{"children":"1.2.1 为什么是 JavaScript"}],"\n",["$","p",null,{"children":"Node 作者明白设计高性能，Web 服务器的几个要点：事件驱动、非阻塞 I/O。作者曾评估过一系列语言，发现 JavaScript 并无非阻塞 I/O 的历史包袱，同时，事件驱动已经在浏览器内得到良好体现。"}],"\n",["$","h4",null,{"children":"1.2.2 为什么叫 Node"}],"\n",["$","p",null,{"children":"Node 发展为一个强制不共享任何资源的单线程、单进程系统，包含十分适宜网络的库，为构建大型分布式应用程序提供基础设施，其目标也是成为一个构建快速、可伸缩的网络应用平台。每一个 Node 进程都构成这个网络应用中的一个节点，这是它名字所含意义的真谛。"}],"\n",["$","h3",null,{"children":"1.3 Node 给 JavaScript 带来的意义"}],"\n",["$","p",null,{"children":"除了 HTML、WebKit 和显卡这些 UI 相关技术没有支持外，Node 的结构与 Chrome 十分相似。它们都是基于事件驱动的异步架构，浏览器通过事件驱动来服务界面上的交互，Node 通过事件驱动来服务 I/O。Node 打破了过去 JavaScript 只能在浏览器中运行的局面。前后端编程环境统一，可以大大降低前后端转换所需要的上下文交换代价。"}],"\n",["$","h3",null,{"children":"1.4 Node 的特点"}],"\n",["$","h4",null,{"children":"1.4.1 异步 I/O"}],"\n",["$","p",null,{"children":"在 Node 中，绝大多数的操作都以异步的方式进行调用。Ryan Dahl 排除万难，在底层构建了很多异步 I/O 的 API，从文件读取到网络请求等，均是如此。这样的意义在于，在 Node 中，我们可以从语言层面很自然地进行并行 I/O 操作。每个调用之间无须等待之前的 I/O 调用结束。在编程模型上可以极大提升效率。下面的两个文件读取任务的耗时取决于最慢的那个文件读取的耗时："}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-js","children":"fs.readFile('/path1', function (err, file) {\nconsole.log(’读取文件 1 完成’);\n});\nfs.readFile('/path2', function (err, file) {\nconsole.log(’读取文件 2 完成’);\n});\n"}]}],"\n",["$","p",null,{"children":"而对于同步 I/O 而言，它们的耗时是两个任务的耗时之和。这里异步带来的优势是显而易见的。"}],"\n",["$","h4",null,{"children":"1.4.2 事件与回调函数"}],"\n",["$","p",null,{"children":"事件的编程方式具有轻量级、松耦合、只关注事务点等优势，但是在多个异步任务的场景下，事件与事件之间各自独立，如何协作是一个问题。回调函数无处不在，这是因为在 JavaScript 中，我们将函数作为第一等公民来对待，可以将函数作为对象传递给方法作为实参进行调用。"}],"\n",["$","p",null,{"children":"在转变为异步编程思维后，通过对业务的划分和对事件的提炼，在流程控制方面处理业务的复杂度与同步方式实际上是一致的。"}],"\n",["$","h4",null,{"children":"1.4.3 单线程"}],"\n",["$","p",null,{"children":"Node 保持了 JavaScript 在浏览器中单线程的特点。而且在 Node 中，JavaScript 与其余线程是无法共享任何状态的。单线程的最大好处是不用像多线程编程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文交换所带来的性能上的开销。"}],"\n",["$","p",null,{"children":"同样，单线程也有它自身的弱点，这些弱点是学习 Node 的过程中必须要面对的。积极面对这些弱点，可以享受到 Node 带来的好处，也能避免潜在的问题，使其得以高效利用。单线程的弱点具体有以下 3 方面。"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"无法利用多核 CPU。"}],"\n",["$","li",null,{"children":"错误会引起整个应用退出，应用的健壮性值得考验。"}],"\n",["$","li",null,{"children":"大量计算占用 CPU 导致无法继续调用异步 I/O。"}],"\n"]}],"\n",["$","h4",null,{"children":"1.4.4 跨平台"}],"\n",["$","p",null,{"children":"通过良好的架构，Node 的第三方 C++模块也可以借助 libuv 实现跨平台。目前，除了没有保持更新的 C++模块外，大部分 C++模块都能实现跨平台的兼容。"}],"\n",["$","h3",null,{"children":"1.5 Node 应用场景"}],"\n",["$","p",null,{"children":"关于 Node，探讨最多的主要有 I/O 密集型和 CPU 密集型。"}],"\n",["$","h3",null,{"children":"1.5.1 I/O 密集型"}],"\n",["$","p",null,{"children":"Node 面向网络且擅长并行 I/O，能够有效地组织起更多的硬件资源，从而提供更好的服务。"}],"\n",["$","h3",null,{"children":"1.5.2 是否不擅长 CPU 密集型业务"}],"\n",["$","p",null,{"children":"实际 V8 执行效率挺高的，在 python 等脚本语言中，Node 其实算是足够高效的，CPU 密集型给 Node 的挑战主要是："}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"js 是单线程，长时间运算会导致 CPU 时间线无法释放。"}],"\n"]}],"\n",["$","p",null,{"children":"如果可以将大型运算拆分成小任务，这样时间片能适时释放，则可以同时享受并行 I/O 和充分利用 CPU。\nCPU 密集不可怕，如何合理调度是诀窍。"}],"\n",["$","h3",null,{"children":"1.5.3 与遗留系统和平共处"}],"\n",["$","p",null,{"children":"Node 将数据源当做数据接口，发挥异步并行的优势，不用关心背后用什么语言实现。"}],"\n",["$","h3",null,{"children":"1.5.4 分布式应用"}],"\n",["$","p",null,{"children":"分布式应用意味着对可伸缩性的要求非常高，阿里巴巴中间层应用 NodeFox 能实现并行地对多台数据库进行获取数据并合并，查询多个数据库如同查询单个数据库一样，充分压榨硬件资源。"}],"\n",["$","h2",null,{"children":"1.6 Node 的使用者"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"前后端语言环境统一"}],"\n",["$","li",null,{"children":"高性能 I/O 用于实时应用"}],"\n",["$","li",null,{"children":"并行 I/O 用于分布式环境"}],"\n",["$","li",null,{"children":"云计算平台采用 Node，发挥低资源占用，高性能优势"}],"\n",["$","li",null,{"children":"游戏开发领域"}],"\n",["$","li",null,{"children":"工具类应用"}],"\n"]}],"\n",["$","h1",null,{"children":"2 模块机制（跳过）"}],"\n",["$","h1",null,{"children":"3 异步 I/O"}],"\n",["$","h2",null,{"children":"3.1 为什么要异步 I/O"}],"\n",["$","p",null,{"children":"Node 面向网络而设计，而并发在网络环境下，是标配。"}],"\n",["$","h3",null,{"children":"3.1.1 用户体验"}],"\n",["$","p",null,{"children":"同步 I/O 在复杂请求下，时间总消耗为 M+N，而异步为 max(M,N),随着网络与应用不断膨胀，数据会分布到多台服务器，分布式是常态，分布也会导致 M 与 N 的值线性增长。"}],"\n",["$","h3",null,{"children":"3.1.2 资源分配"}],"\n",["$","p",null,{"children":"业务场景中有一组互不相关的 Task 需要完成，现在的主流方法是："}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"单线程串行执行"}],"\n",["$","li",null,{"children":"多线程并行执行"}],"\n"]}],"\n",["$","p",null,{"children":"如果创建多线程的开销小于并行执行，那么多线程是首选，其代价在于创建和切换上下文的开销较大。另外，复杂业务中，多线程也经常面临锁，状态同步问题。但是多线程能在多核 CPU 上有效提升 CPU 利用率，其优势毋庸置疑。"}],"\n",["$","p",null,{"children":"单线程串行执行比较符合编程人员的思考方式，它容易表达，但同时性能有严重问题，任何一个慢任务都会阻塞，造成资源无法良好利用。"}],"\n",["$","p",null,{"children":["Node 给出了自己的方案：利用单线程，远离多线程死锁，状态同步问题；利用异步 I/O，让单线程远离阻塞，充分利用 CPU。",["$","a",null,{"href":"https://www.zhihu.com/question/523481325/answer/2408443982","children":"关于异步 I/O 是否要加锁，可以看下这篇帖子，感觉挺有意思。"}]]}],"\n",["$","h2",null,{"children":"3.2 异步 I/O 实现现状"}],"\n",["$","p",null,{"children":"异步 I/O 在 Node 中应用非常广泛，但它并非 Node 的原创。"}],"\n",["$","h3",null,{"children":"3.2.1 异步 I/O 与非阻塞 I/O"}],"\n",["$","p",null,{"children":"异步与非阻塞听起来似乎同一回事，从实际效果看，它们都达到了并行 I/O 的目的。但对计算机内核而言，这是两码事。"}],"\n",["$","p",null,{"children":"操作系统内核对于 I/O 只有两种方式：阻塞和非阻塞，在调用阻塞 I/O 时，应用需等待内核处理 I/O 完成才能拿到结果。"}],"\n",["$","p",null,{"children":"操作系统对计算机进行了抽象，将所有输入输出抽象为文件，内核在进行 I/O 操作时，是通过文件描述符（类似于应用于内核间的凭证）进行管理。"}],"\n",["$","p",null,{"children":"应用程序如果进行 I/O 调用，需要先打开文件描述符，根据它进行文件读写，在非阻塞 I/O 情况下，内核不直接返回数据，应用想获取数据，则需要通过文件描述符再次读取。在此期间，CPU 时间片可以用来处理其他事务，此时性能提升很明显。"}],"\n",["$","p",null,{"children":"但它也存在一些问题，由于完整 I/O 并未完成，立即返回的并不是业务层期望的数据，而仅仅是调用的状态，为了获取完整的数据，需要重复调用 I/O 操作来确认状态，从而确认是否完成了本次 I/O。这种技术叫做轮询。"}],"\n",["$","p",null,{"children":"下面我们来看轮询技术是如何一步步推进，已减小 I/O 状态判断对于 CPU 的损耗。"}],"\n",["$","p",null,{"children":"read: 最原始，性能最低的一种。重复调用 I/O 来检查状态，在得到数据之前，CPU 一直在等待中。\nselect: 通过文件描述符的事件状态来判断状态，但有个限制，它采用 1024 长度的数组存储状态，最多只能检查 1024 个文件描述符。\npoll: 采用链表来存储状态，没有长度限制，但当文件描述符过多时，性能依然低下。\nepoll: 采用事件通知机制，如果没检测到 I/O 事件，它将进入休眠，知道事件发生才唤醒，它利用了事件通知，回调形式，执行效率较高。\nkqueue: 方案类似 epoll，但仅在 FreeBSD 系统存在。"}],"\n",["$","p",null,{"children":"轮询技术能确保获取完整需求，但此时 CPU 要么用于遍历文件描述符状态，要么休眠等待事件发生，不够好。"}],"\n",["$","h3",null,{"children":"3.2.2 理想的非阻塞/异步 I/O"}],"\n",["$","p",null,{"children":"epoll 利用事件通知降低 CPU 消耗，但休眠期间 CPU 几乎是闲置的，利用率不够。期待的完美方案应该是：应用发起 I/O 事件，无需通过遍历或事件唤醒等方式轮询，直接处理下一个任务，只需在完成时通过信号/回调将数据传递给应用即可。"}],"\n",["$","p",null,{"children":"幸运的是 linux 原生提供这种方式 AIO，但它只局限于 linux 同时无法利用系统缓存。"}],"\n",["$","h3",null,{"children":"3.2.3 现实的异步 I/O"}],"\n",["$","p",null,{"children":"之前我们将场景局限在单线程中，多线程将是另外一番风景。通过部分线程阻塞或非阻塞 I/O + 轮询来获取数据，让一个线程计算处理，通过线程通信传递数据，这就实现了模拟的异步 I/O。"}]]]}]
